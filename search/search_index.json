{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Scipy This tutorial guide you to fundamentals of Pandas for DataFrame, indexing, subframing, meging, concatation, plotting, lambda transformation etc. Imag courtesy: Data-Flair cluster - Hierarchical clustering. constants - Physical constants and factors of conversion. fftpack - Algorithms for Discrete Fourier Transform. integrate - Routines for numerical integration. interpolate - Tools for interpolation. io - Input and Output tools for data. lib - Wrappers to external libraries. linalg - Routines for linear algebra. misc - Miscellaneous utilities like image reading and writing. ndimage - Functions for processing multidimensional images. optimize - Algorithms for optimization. signal - Tools for processing signal. sparse - Algorithms for sparse matrices. spatial - KD-trees, distance functions, nearest neighbors. special - Special functions. stats - Functions to perform statistics.","title":"Home"},{"location":"#introduction-to-scipy","text":"This tutorial guide you to fundamentals of Pandas for DataFrame, indexing, subframing, meging, concatation, plotting, lambda transformation etc. Imag courtesy: Data-Flair cluster - Hierarchical clustering. constants - Physical constants and factors of conversion. fftpack - Algorithms for Discrete Fourier Transform. integrate - Routines for numerical integration. interpolate - Tools for interpolation. io - Input and Output tools for data. lib - Wrappers to external libraries. linalg - Routines for linear algebra. misc - Miscellaneous utilities like image reading and writing. ndimage - Functions for processing multidimensional images. optimize - Algorithms for optimization. signal - Tools for processing signal. sparse - Algorithms for sparse matrices. spatial - KD-trees, distance functions, nearest neighbors. special - Special functions. stats - Functions to perform statistics.","title":"Introduction to Scipy"},{"location":"Bessel/Bessel/","text":"Bessel Functions Scipy Library: Source In this notebook we are going to make some fun with Oscillating membrane implementing Bessel Functions. import numpy as np from scipy.special import jn, yn, jn_zeros, yn_zeros import scipy as sci import scipy.special as sp from __future__ import division import matplotlib.pyplot as plt import matplotlib import pylab from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors % matplotlib inline import seaborn as sns sns . set() Bessel Functions n = 0 # order x = 0.0 # Bessel function of first kind print ( \"J_ %d ( %f ) = %f \" % (n, x, jn(n, x))) x = 1.0 # Bessel function of second kind print ( \"Y_ %d ( %f ) = %f \" % (n, x, yn(n, x))) J_0(0.000000) = 1.000000 Y_0(1.000000) = 0.088257 x = np . linspace( 0 , 30 , 100 ) plt . figure(figsize = ( 15 , 8 )) for n in range ( 10 ): plt . plot(x, jn(n, x), label = r\"$J_ %d (x)$\" % n) plt . legend(); Vibrating Circular Membrane The vibrations of a thin circular membrane stretched across a rigid circular frame (such as a drum head) can be described as normal modes written in terms of Bessel functions: \\( \\large{z(r,\u03b8;t)=AJ_n(kr)\\sin(n\u03b8)\\cos(k\u03bdt)}\\) where $(r,\u03b8)$ describes a position in polar co-ordinates with the origin at the centre of the membrane, t is time and v is a constant depending on the tension and surface density of the drum. The modes are labelled by integers $n=0,1,\u22ef $ and $m=1,2,3,\u22ef$ where k is the mth zero of $J_n$. The following program produces a plot of the displacement of the membrane in the n=3,m=2 normal mode at time t=0. Table p q --- --- --- --- --- --- def displacement (n, m, r, theta): \"\"\" Calculate the displacement of the drum membrane at (r, theta; t=0) in the normal mode described by integers n >= 0, 0 < m <= mmax. \"\"\" # Pick off the mth zero of Bessel function Jn k = jn_zeros(n, mmax + 1 )[m] return np . sin(n * theta) * jn(n, r * k) Oscillating membrane ( SIngle Plot, (2,0)) # Allow calculations up to m = mmax mmax = 10 # Positions on the drum surface are specified in polar co-ordinates r = np . linspace( 0 , 1 , 100 ) theta = np . linspace( 0 , 2 * np . pi, 100 ) # Create arrays of cartesian co-ordinates (x, y) ... x = np . array([rr * np . cos(theta) for rr in r]) y = np . array([rr * np . sin(theta) for rr in r]) # ... and vertical displacement (z) for the required normal mode at # time, t = 0 n0, m0 = 2 , 0 z = np . array([displacement(n0, m0, rr, theta) for rr in r]) plt . figure(figsize = [ 8 , 8 ]) pylab . contour(x, y, z) pylab . show() Oscilating Membrane ( Single, 3D plot, (2,0)) r, theta = np . mgrid[ 0 : 1 : 100 j, 0 : 2 * np . pi: 100 j] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 15 , 8 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 ); Oscillating Membrane (Multiplot) plt . figure(figsize = [ 15 , 25 ]) k = 0 for n in range ( 6 ): for m in range (n - 1 ): k = k + 1 z = np . array([displacement(n, m, rr, theta) for rr in r]) plt . subplot( 5 , 3 ,k) plt . title( str (n) + str (m)) pylab . contour(x, y, z) pylab . show() Oscilating Membrane ( m,n = 2,2) n0,m0 = 2 , 2 r, theta = np . mgrid[ 0 : 1 : 100 j, 0 : 2 * np . pi: 100 j] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 15 , 8 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 ); References https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"Oscillating Membrane"},{"location":"Bessel/Bessel/#bessel-functions","text":"Scipy Library: Source In this notebook we are going to make some fun with Oscillating membrane implementing Bessel Functions. import numpy as np from scipy.special import jn, yn, jn_zeros, yn_zeros import scipy as sci import scipy.special as sp from __future__ import division import matplotlib.pyplot as plt import matplotlib import pylab from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors % matplotlib inline import seaborn as sns sns . set()","title":"Bessel Functions"},{"location":"Bessel/Bessel/#bessel-functions_1","text":"n = 0 # order x = 0.0 # Bessel function of first kind print ( \"J_ %d ( %f ) = %f \" % (n, x, jn(n, x))) x = 1.0 # Bessel function of second kind print ( \"Y_ %d ( %f ) = %f \" % (n, x, yn(n, x))) J_0(0.000000) = 1.000000 Y_0(1.000000) = 0.088257 x = np . linspace( 0 , 30 , 100 ) plt . figure(figsize = ( 15 , 8 )) for n in range ( 10 ): plt . plot(x, jn(n, x), label = r\"$J_ %d (x)$\" % n) plt . legend();","title":"Bessel Functions"},{"location":"Bessel/Bessel/#vibrating-circular-membrane","text":"The vibrations of a thin circular membrane stretched across a rigid circular frame (such as a drum head) can be described as normal modes written in terms of Bessel functions: \\( \\large{z(r,\u03b8;t)=AJ_n(kr)\\sin(n\u03b8)\\cos(k\u03bdt)}\\) where $(r,\u03b8)$ describes a position in polar co-ordinates with the origin at the centre of the membrane, t is time and v is a constant depending on the tension and surface density of the drum. The modes are labelled by integers $n=0,1,\u22ef $ and $m=1,2,3,\u22ef$ where k is the mth zero of $J_n$. The following program produces a plot of the displacement of the membrane in the n=3,m=2 normal mode at time t=0. Table p q --- --- --- --- --- --- def displacement (n, m, r, theta): \"\"\" Calculate the displacement of the drum membrane at (r, theta; t=0) in the normal mode described by integers n >= 0, 0 < m <= mmax. \"\"\" # Pick off the mth zero of Bessel function Jn k = jn_zeros(n, mmax + 1 )[m] return np . sin(n * theta) * jn(n, r * k)","title":"Vibrating Circular Membrane"},{"location":"Bessel/Bessel/#oscillating-membrane-single-plot-20","text":"# Allow calculations up to m = mmax mmax = 10 # Positions on the drum surface are specified in polar co-ordinates r = np . linspace( 0 , 1 , 100 ) theta = np . linspace( 0 , 2 * np . pi, 100 ) # Create arrays of cartesian co-ordinates (x, y) ... x = np . array([rr * np . cos(theta) for rr in r]) y = np . array([rr * np . sin(theta) for rr in r]) # ... and vertical displacement (z) for the required normal mode at # time, t = 0 n0, m0 = 2 , 0 z = np . array([displacement(n0, m0, rr, theta) for rr in r]) plt . figure(figsize = [ 8 , 8 ]) pylab . contour(x, y, z) pylab . show()","title":"Oscillating membrane ( SIngle Plot, (2,0))"},{"location":"Bessel/Bessel/#oscilating-membrane-single-3d-plot-20","text":"r, theta = np . mgrid[ 0 : 1 : 100 j, 0 : 2 * np . pi: 100 j] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 15 , 8 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 );","title":"Oscilating Membrane ( Single, 3D plot, (2,0))"},{"location":"Bessel/Bessel/#oscillating-membrane-multiplot","text":"plt . figure(figsize = [ 15 , 25 ]) k = 0 for n in range ( 6 ): for m in range (n - 1 ): k = k + 1 z = np . array([displacement(n, m, rr, theta) for rr in r]) plt . subplot( 5 , 3 ,k) plt . title( str (n) + str (m)) pylab . contour(x, y, z) pylab . show()","title":"Oscillating Membrane (Multiplot)"},{"location":"Bessel/Bessel/#oscilating-membrane-mn-22","text":"n0,m0 = 2 , 2 r, theta = np . mgrid[ 0 : 1 : 100 j, 0 : 2 * np . pi: 100 j] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 15 , 8 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 );","title":"Oscilating Membrane ( m,n = 2,2)"},{"location":"Bessel/Bessel/#references","text":"https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"References"},{"location":"Harmonics/Harmonics/","text":"Spherical Harmonics Scipy Library: Source In this notebook we are going to make some fun with Spherical Harmonics. import numpy as np from scipy.special import jn, yn, jn_zeros, yn_zeros import scipy as sci import scipy.special as sp from __future__ import division import matplotlib.pyplot as plt import matplotlib import pylab from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors % matplotlib inline import seaborn as sns sns . set() Spherical Harmonics \\( Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}} e^{i m \\theta} P^m_n(\\cos(\\phi)) \\) Some Examples \\( Y_0^0(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\) \\( Y_1^{-1}(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{-i\\theta} \\sin(\\phi) \\) \\( Y_1^0(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}} \\cos(\\phi) \\) \\( Y_1^1(\\theta, \\phi) = -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{i\\theta} \\sin(\\phi) \\) PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables Spherical Harmonics : Y(1,0) l = 1 #degree m = 0 #order R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) # Normalize R for the plot colors to cover the entire range of colormap. N = R / R . max() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^1_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); Spherical Harmonics : Y(2,0) and Y(2,1) l = 2 #degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^2_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 2 # degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/\\ #normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^2_ 1)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 ); Spherical Harmonics : Y(4,2) l = 4 #degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover # the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 ,\\ facecolors = cm . jet(N)) ax . set_title( r'$|Y^4_ 2|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 4 # degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/\\ #normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 ,\\ facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^4_ 2)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 ); References https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"Spherical Harmonics"},{"location":"Harmonics/Harmonics/#spherical-harmonics","text":"Scipy Library: Source In this notebook we are going to make some fun with Spherical Harmonics. import numpy as np from scipy.special import jn, yn, jn_zeros, yn_zeros import scipy as sci import scipy.special as sp from __future__ import division import matplotlib.pyplot as plt import matplotlib import pylab from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors % matplotlib inline import seaborn as sns sns . set()","title":"Spherical Harmonics"},{"location":"Harmonics/Harmonics/#spherical-harmonics_1","text":"\\( Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}} e^{i m \\theta} P^m_n(\\cos(\\phi)) \\) Some Examples \\( Y_0^0(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\) \\( Y_1^{-1}(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{-i\\theta} \\sin(\\phi) \\) \\( Y_1^0(\\theta, \\phi) = \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}} \\cos(\\phi) \\) \\( Y_1^1(\\theta, \\phi) = -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{i\\theta} \\sin(\\phi) \\) PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables","title":"Spherical Harmonics"},{"location":"Harmonics/Harmonics/#spherical-harmonics-y10","text":"l = 1 #degree m = 0 #order R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) # Normalize R for the plot colors to cover the entire range of colormap. N = R / R . max() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^1_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 );","title":"Spherical Harmonics : Y(1,0)"},{"location":"Harmonics/Harmonics/#spherical-harmonics-y20-and-y21","text":"l = 2 #degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^2_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 2 # degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/\\ #normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^2_ 1)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 );","title":"Spherical Harmonics :  Y(2,0) and Y(2,1)"},{"location":"Harmonics/Harmonics/#spherical-harmonics-y42","text":"l = 4 #degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover # the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 ,\\ facecolors = cm . jet(N)) ax . set_title( r'$|Y^4_ 2|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 4 # degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200 j, 0 :np . pi: 100 j] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/\\ #normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ),\\ figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 ,\\ cstride = 1 ,\\ facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^4_ 2)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 );","title":"Spherical Harmonics :  Y(4,2)"},{"location":"Harmonics/Harmonics/#references","text":"https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"References"},{"location":"Laplace/laplace/","text":"Laplace Equation We want to solve Laplace equation both analytically and Computationally. Laplace equation in 2D is : \\( \\frac{d^2U}{dx^2} + \\frac{d^2U}{dy^2} = 0 \\) Analytic Solution By considering \\( U(x,y) = X(x)Y(y) \\) one can solve the equation to get analytic solution using periodic boundary conditions \\( U(x,y) = \\sum_{n=1}^{\\infty}E_{n} \\sin \\frac{n\\pi x}{L}\\sinh\\frac{n\\pi y}{L} \\) Where $E_n$ is a constant to be set by further boundary condition. Computational Method There are two methods Method of finite Difference We divide the entire square in to the lattice with equal spacing $\\triangle$ in both in the x and y directions. The x and y variables are now discrete: \\( x = x_o + i\\triangle \\); \\( y = y_o + i\\triangle \\); Where, \\( i,j = 0,N_{max} = L/D \\) We represent the potential by the arrey \\( U(N_{Max},N_{Max}) \\) Finite Difference Algorithm \\( U(i,j) = \\frac{1}{4}[U(i+1,j)+ U(i-1,j) + U(i,j+1) + U(i,j-1)] \\) Boundary Conditions \\( U(i,N_{max}) = 100, \\) (top) \\( U(1,j) = 0, \\) (left) \\( U(N_{max},j) = 0, \\) (right) \\( U(i,1) = 0, \\) (bottom) We define a function to control boundary conditions. Coding import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import seaborn as sns sns . set() import random '''constants''' N = 100 # Number of lattice points Nitr = 1000 # Number of iterations def fun (k): if k == 0 : return 1 else : return 0 Initiate list to hold 2D array of U U = [[ 0.0 for x in range (N)] for y in range (N)] Now we want to impose boundary conditions def boundary_conditions (U): for i in range (N): U[i][N - 1 ] = 100.0 for j in range (N): U[ 0 ][j] = 0.0 for j in range (N): U[N - 1 ][j] = 0.0 for i in range (N): U[i][ 0 ] = 0.0 return U Now we iterate with this begining configurations: itr = 0 boundary_conditions(U) while itr < Nitr: for i in range (N): for j in range (N): U[i][j] = ( 0.25 ) * (U[(i + 1 ) % N][j] + \\ U[(i - 1 ) + (fun(i) * N)][j] + U[i][(j + 1 ) % N] + \\ U[i][(j - 1 ) + (fun(j) * N)]) boundary_conditions(U) itr = itr + 1 def val (i,j): return U[i][j] fig = plt . figure(figsize = [ 15 , 8 ]) ax = fig . add_subplot( 111 , projection = '3d' ) x = y = np . arange( 0 , N, 1 ) X, Y = np . meshgrid(x, y) ax . set_xlabel( 'X Label' ) ax . set_ylabel( 'Y Label' ) ax . set_zlabel( 'Z Label' ) zs = np . array([val(x,y) for x,y in zip (np . ravel(X), np . ravel(Y))]) Z = zs . reshape(X . shape) ax . plot_surface(X, Y, Z) plt . show()","title":"Laplace Equation"},{"location":"Laplace/laplace/#laplace-equation","text":"We want to solve Laplace equation both analytically and Computationally. Laplace equation in 2D is : \\( \\frac{d^2U}{dx^2} + \\frac{d^2U}{dy^2} = 0 \\)","title":"Laplace Equation"},{"location":"Laplace/laplace/#analytic-solution","text":"By considering \\( U(x,y) = X(x)Y(y) \\) one can solve the equation to get analytic solution using periodic boundary conditions \\( U(x,y) = \\sum_{n=1}^{\\infty}E_{n} \\sin \\frac{n\\pi x}{L}\\sinh\\frac{n\\pi y}{L} \\) Where $E_n$ is a constant to be set by further boundary condition.","title":"Analytic Solution"},{"location":"Laplace/laplace/#computational-method","text":"There are two methods Method of finite Difference We divide the entire square in to the lattice with equal spacing $\\triangle$ in both in the x and y directions. The x and y variables are now discrete: \\( x = x_o + i\\triangle \\); \\( y = y_o + i\\triangle \\); Where, \\( i,j = 0,N_{max} = L/D \\) We represent the potential by the arrey \\( U(N_{Max},N_{Max}) \\) Finite Difference Algorithm \\( U(i,j) = \\frac{1}{4}[U(i+1,j)+ U(i-1,j) + U(i,j+1) + U(i,j-1)] \\) Boundary Conditions \\( U(i,N_{max}) = 100, \\) (top) \\( U(1,j) = 0, \\) (left) \\( U(N_{max},j) = 0, \\) (right) \\( U(i,1) = 0, \\) (bottom) We define a function to control boundary conditions.","title":"Computational Method"},{"location":"Laplace/laplace/#coding","text":"import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import seaborn as sns sns . set() import random '''constants''' N = 100 # Number of lattice points Nitr = 1000 # Number of iterations def fun (k): if k == 0 : return 1 else : return 0 Initiate list to hold 2D array of U U = [[ 0.0 for x in range (N)] for y in range (N)] Now we want to impose boundary conditions def boundary_conditions (U): for i in range (N): U[i][N - 1 ] = 100.0 for j in range (N): U[ 0 ][j] = 0.0 for j in range (N): U[N - 1 ][j] = 0.0 for i in range (N): U[i][ 0 ] = 0.0 return U Now we iterate with this begining configurations: itr = 0 boundary_conditions(U) while itr < Nitr: for i in range (N): for j in range (N): U[i][j] = ( 0.25 ) * (U[(i + 1 ) % N][j] + \\ U[(i - 1 ) + (fun(i) * N)][j] + U[i][(j + 1 ) % N] + \\ U[i][(j - 1 ) + (fun(j) * N)]) boundary_conditions(U) itr = itr + 1 def val (i,j): return U[i][j] fig = plt . figure(figsize = [ 15 , 8 ]) ax = fig . add_subplot( 111 , projection = '3d' ) x = y = np . arange( 0 , N, 1 ) X, Y = np . meshgrid(x, y) ax . set_xlabel( 'X Label' ) ax . set_ylabel( 'Y Label' ) ax . set_zlabel( 'Z Label' ) zs = np . array([val(x,y) for x,y in zip (np . ravel(X), np . ravel(Y))]) Z = zs . reshape(X . shape) ax . plot_surface(X, Y, Z) plt . show()","title":"Coding"},{"location":"intro/Numerical-Methods/","text":"Numerical Methods: Integration Differential Equations Integration source import numpy as np from scipy.integrate import quad, dblquad, tplquad $$ y = mx +c$$ def f (x): return 5 * x + 4 x_lower = 0 # the lower limit of x x_upper = 1 # the upper limit of x val, abserr = quad(f, x_lower, x_upper) print ( \"integral value =\" , val, \", absolute error =\" , abserr) integral value = 6.499999999999999 , absolute error = 7.216449660063516e-14 Bessel function from scipy.special import jn, yn, jn_zeros, yn_zeros def integrand (x, n): \"\"\" Bessel function of first kind and order n. \"\"\" return jn(n, x) x_lower = 0 # the lower limit of x x_upper = 10 # the upper limit of x val, abserr = quad(integrand, x_lower, x_upper, args = ( 3 ,)) print (val, abserr) 0.7366751370811073 9.389126882496403e-13 Gaussian function val, abserr = quad( lambda x: np . exp( - x ** 2 ), - 5.0 , 5.0 ) print ( \"numerical =\" , val, abserr) analytical = np . sqrt(np . pi) print ( \"analytical =\" , analytical) numerical = 1.7724538509027912 4.6261378229003154e-14 analytical = 1.7724538509055159 def integrand (x, y): return np . exp( - x ** 2 - y ** 2 ) x_lower = 0 x_upper = 10 y_lower = 0 y_upper = 10 val, abserr = dblquad(integrand, x_lower, x_upper,\\ lambda x : y_lower, lambda x: y_upper) print (val, abserr) 0.7853981633974476 1.3753098510218528e-08 Ordinary Differential Equations Source Odent Source from scipy.integrate import odeint, ode def dy (y, t, zeta, w0): \"\"\" The right-hand side of the damped oscillator ODE \"\"\" x, p = y[ 0 ], y[ 1 ] dx = p dp = - 2 * zeta * w0 * p - w0 ** 2 * x return [dx, dp] # initial state: y0 = [ 1.0 , 0.0 ] # time coodinate to solve the ODE for t = np . linspace( 0 , 10 , 1000 ) w0 = 2 * np . pi * 1.0 # solve the ODE problem for three different values of the damping ratio y1 = odeint(dy, y0, t, args = ( 0.0 , w0)) # undamped y2 = odeint(dy, y0, t, args = ( 0.2 , w0)) # under damped y3 = odeint(dy, y0, t, args = ( 1.0 , w0)) # critial damping y4 = odeint(dy, y0, t, args = ( 5.0 , w0)) # over damped plt . figure(figsize = [ 10 , 8 ]) plt . plot(t, y1[:, 0 ], 'k' , label = \"undamped\" , linewidth = 0.25 ) plt . plot(t, y2[:, 0 ], 'r' , label = \"under damped\" ) plt . plot(t, y3[:, 0 ], 'b' , label = r\"critical damping\" ) plt . plot(t, y4[:, 0 ], 'g' , label = \"over damped\" ) plt . legend(); Partial Differential Equations PDE : Eliptic Equation (Laplace Euation) $$ \\nabla^{2} u + c f(u) = 0 $$ $$\\frac{\\partial^{2}u}{\\partial^{2}x} + \\frac{\\partial^{2}u}{\\partial^{2}x} + cf(u) = 0$$ for $c=1, f(u)=0$ it becomes Laplace Equation Using Above lattice of finite difference: $$\\large{u_{i\u22121,j}+u_{i+1,j} + u_{i,j\u22121} + u{i,j+1} \u2212 4u_{i,j}+cf(u_{i,j})=0}$$ $$u_{i,j}=0; \\forall u \\in \u2202\u03a9$$ for 4 by 4 lattice view matrices here: source Problem Type : Solve $$\\large{Ax = b}$$ Implementation of Least square methods to solve a $Ax = b$ problem as a optimization problem % matplotlib inline import matplotlib.pyplot as plt import numpy as np from scipy.optimize import least_squares from scipy.sparse import coo_matrix import seaborn as sns sns . set() n = 100 c = 1 def f (u): return u ** 3 def f_prime (u): return 3 * u ** 2 Prepare the lattice def fun (u, n,f, f_prime,c, ** kwargs): v = np . zeros((n + 2 , n + 2 )) #buttom value = 1 v[n + 1 ,:] = 1 # top value = 1 #v[0,:] = 1 # center value = 1 #v[int(n/2),int(n/2)] = 1 u = u . reshape((n, n)) v[ 1 : - 1 , 1 : - 1 ] = u y = v[: - 2 , 1 : - 1 ] + v[ 2 :, 1 : - 1 ] + \\ v[ 1 : - 1 , : - 2 ] + v[ 1 : - 1 , 2 :] - \\ 4 * u + c * f(u) return y . ravel() Prepare Jacobians def compute_jac_indices (n): i = np . arange(n) jj, ii = np . meshgrid(i, i) ii = ii . ravel() jj = jj . ravel() ij = np . arange(n ** 2 ) jac_rows = [ij] jac_cols = [ij] mask = ii > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - n) mask = ii < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + n) mask = jj > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - 1 ) mask = jj < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + 1 ) return np . hstack(jac_rows), np . hstack(jac_cols) jac_rows, jac_cols = compute_jac_indices(n) jac_rows, jac_cols (array([ 0, 1, 2, ..., 9996, 9997, 9998]), array([ 0, 1, 2, ..., 9997, 9998, 9999])) def jac (u, n,f, f_prime,c, jac_rows = None , jac_cols = None ): jac_values = np . ones_like(jac_cols, dtype = float ) jac_values[:n ** 2 ] = - 4 + c * f_prime(u) return coo_matrix((jac_values, (jac_rows, jac_cols)), shape = (n ** 2 , n ** 2 )) u0 = np . ones(n ** 2 ) * 0.5 Optimization: Least Square res_1 = least_squares(fun, u0, jac = jac, gtol = 1e-3 , args = (n,f, f_prime,c),\\ kwargs = { 'jac_rows' : jac_rows, 'jac_cols' : jac_cols}, verbose = 1 ) `gtol` termination condition is satisfied. Function evaluations 738, initial cost 1.1562e+02, final cost 6.4462e-01, first-order optimality 9.38e-04. Returned quantities after solution res_1 . x . shape (10000,) res_1 . x array([0.00622038, 0.01236634, 0.01833963, ..., 0.01834064, 0.01236645, 0.00622026]) res_1 . fun array([-0.00014825, -0.00029118, -0.00041394, ..., -0.000414 , -0.00029121, -0.00014826]) res_1 . fun . shape (10000,) res_1 . jac <10000x10000 sparse matrix of type '<class 'numpy.float64'>' with 49600 stored elements in Compressed Sparse Row format> Plot the solutions plt . figure(figsize = ( 16 , 5 )) plt . subplot( 131 ) plt . plot(res_1 . x) plt . subplot( 132 ) plt . imshow(res_1 . x . reshape((n, n)),\\ cmap = 'coolwarm' ,\\ vmin =- max ( abs (res_1 . x)),\\ vmax = max ( abs (res_1 . x))) plt . colorbar(use_gridspec = True ,\\ fraction = 0.046 ,\\ pad = 0.04 ) plt . subplot( 133 ) plt . plot(res_1 . fun) plt . tight_layout() References: http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main055.html https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares","title":"Introduction"},{"location":"intro/Numerical-Methods/#numerical-methods","text":"Integration Differential Equations","title":"Numerical Methods:"},{"location":"intro/Numerical-Methods/#integration-source","text":"import numpy as np from scipy.integrate import quad, dblquad, tplquad $$ y = mx +c$$ def f (x): return 5 * x + 4 x_lower = 0 # the lower limit of x x_upper = 1 # the upper limit of x val, abserr = quad(f, x_lower, x_upper) print ( \"integral value =\" , val, \", absolute error =\" , abserr) integral value = 6.499999999999999 , absolute error = 7.216449660063516e-14","title":"Integration source"},{"location":"intro/Numerical-Methods/#bessel-function","text":"from scipy.special import jn, yn, jn_zeros, yn_zeros def integrand (x, n): \"\"\" Bessel function of first kind and order n. \"\"\" return jn(n, x) x_lower = 0 # the lower limit of x x_upper = 10 # the upper limit of x val, abserr = quad(integrand, x_lower, x_upper, args = ( 3 ,)) print (val, abserr) 0.7366751370811073 9.389126882496403e-13","title":"Bessel function"},{"location":"intro/Numerical-Methods/#gaussian-function","text":"val, abserr = quad( lambda x: np . exp( - x ** 2 ), - 5.0 , 5.0 ) print ( \"numerical =\" , val, abserr) analytical = np . sqrt(np . pi) print ( \"analytical =\" , analytical) numerical = 1.7724538509027912 4.6261378229003154e-14 analytical = 1.7724538509055159 def integrand (x, y): return np . exp( - x ** 2 - y ** 2 ) x_lower = 0 x_upper = 10 y_lower = 0 y_upper = 10 val, abserr = dblquad(integrand, x_lower, x_upper,\\ lambda x : y_lower, lambda x: y_upper) print (val, abserr) 0.7853981633974476 1.3753098510218528e-08","title":"Gaussian function"},{"location":"intro/Numerical-Methods/#ordinary-differential-equations-source","text":"Odent Source from scipy.integrate import odeint, ode def dy (y, t, zeta, w0): \"\"\" The right-hand side of the damped oscillator ODE \"\"\" x, p = y[ 0 ], y[ 1 ] dx = p dp = - 2 * zeta * w0 * p - w0 ** 2 * x return [dx, dp] # initial state: y0 = [ 1.0 , 0.0 ] # time coodinate to solve the ODE for t = np . linspace( 0 , 10 , 1000 ) w0 = 2 * np . pi * 1.0 # solve the ODE problem for three different values of the damping ratio y1 = odeint(dy, y0, t, args = ( 0.0 , w0)) # undamped y2 = odeint(dy, y0, t, args = ( 0.2 , w0)) # under damped y3 = odeint(dy, y0, t, args = ( 1.0 , w0)) # critial damping y4 = odeint(dy, y0, t, args = ( 5.0 , w0)) # over damped plt . figure(figsize = [ 10 , 8 ]) plt . plot(t, y1[:, 0 ], 'k' , label = \"undamped\" , linewidth = 0.25 ) plt . plot(t, y2[:, 0 ], 'r' , label = \"under damped\" ) plt . plot(t, y3[:, 0 ], 'b' , label = r\"critical damping\" ) plt . plot(t, y4[:, 0 ], 'g' , label = \"over damped\" ) plt . legend();","title":"Ordinary Differential Equations Source"},{"location":"intro/Numerical-Methods/#partial-differential-equations","text":"","title":"Partial Differential Equations"},{"location":"intro/Numerical-Methods/#pde-eliptic-equation-laplace-euation","text":"$$ \\nabla^{2} u + c f(u) = 0 $$ $$\\frac{\\partial^{2}u}{\\partial^{2}x} + \\frac{\\partial^{2}u}{\\partial^{2}x} + cf(u) = 0$$ for $c=1, f(u)=0$ it becomes Laplace Equation Using Above lattice of finite difference: $$\\large{u_{i\u22121,j}+u_{i+1,j} + u_{i,j\u22121} + u{i,j+1} \u2212 4u_{i,j}+cf(u_{i,j})=0}$$ $$u_{i,j}=0; \\forall u \\in \u2202\u03a9$$ for 4 by 4 lattice view matrices here: source Problem Type : Solve $$\\large{Ax = b}$$","title":"PDE : Eliptic Equation (Laplace Euation)"},{"location":"intro/Numerical-Methods/#implementation-of-least-square-methods-to-solve-a-ax-b-problem-as-a-optimization-problem","text":"% matplotlib inline import matplotlib.pyplot as plt import numpy as np from scipy.optimize import least_squares from scipy.sparse import coo_matrix import seaborn as sns sns . set() n = 100 c = 1 def f (u): return u ** 3 def f_prime (u): return 3 * u ** 2","title":"Implementation of Least square methods to solve a $Ax = b$ problem as a optimization problem"},{"location":"intro/Numerical-Methods/#prepare-the-lattice","text":"def fun (u, n,f, f_prime,c, ** kwargs): v = np . zeros((n + 2 , n + 2 )) #buttom value = 1 v[n + 1 ,:] = 1 # top value = 1 #v[0,:] = 1 # center value = 1 #v[int(n/2),int(n/2)] = 1 u = u . reshape((n, n)) v[ 1 : - 1 , 1 : - 1 ] = u y = v[: - 2 , 1 : - 1 ] + v[ 2 :, 1 : - 1 ] + \\ v[ 1 : - 1 , : - 2 ] + v[ 1 : - 1 , 2 :] - \\ 4 * u + c * f(u) return y . ravel()","title":"Prepare the lattice"},{"location":"intro/Numerical-Methods/#prepare-jacobians","text":"def compute_jac_indices (n): i = np . arange(n) jj, ii = np . meshgrid(i, i) ii = ii . ravel() jj = jj . ravel() ij = np . arange(n ** 2 ) jac_rows = [ij] jac_cols = [ij] mask = ii > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - n) mask = ii < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + n) mask = jj > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - 1 ) mask = jj < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + 1 ) return np . hstack(jac_rows), np . hstack(jac_cols) jac_rows, jac_cols = compute_jac_indices(n) jac_rows, jac_cols (array([ 0, 1, 2, ..., 9996, 9997, 9998]), array([ 0, 1, 2, ..., 9997, 9998, 9999])) def jac (u, n,f, f_prime,c, jac_rows = None , jac_cols = None ): jac_values = np . ones_like(jac_cols, dtype = float ) jac_values[:n ** 2 ] = - 4 + c * f_prime(u) return coo_matrix((jac_values, (jac_rows, jac_cols)), shape = (n ** 2 , n ** 2 )) u0 = np . ones(n ** 2 ) * 0.5","title":"Prepare Jacobians"},{"location":"intro/Numerical-Methods/#optimization-least-square","text":"res_1 = least_squares(fun, u0, jac = jac, gtol = 1e-3 , args = (n,f, f_prime,c),\\ kwargs = { 'jac_rows' : jac_rows, 'jac_cols' : jac_cols}, verbose = 1 ) `gtol` termination condition is satisfied. Function evaluations 738, initial cost 1.1562e+02, final cost 6.4462e-01, first-order optimality 9.38e-04.","title":"Optimization: Least Square"},{"location":"intro/Numerical-Methods/#returned-quantities-after-solution","text":"res_1 . x . shape (10000,) res_1 . x array([0.00622038, 0.01236634, 0.01833963, ..., 0.01834064, 0.01236645, 0.00622026]) res_1 . fun array([-0.00014825, -0.00029118, -0.00041394, ..., -0.000414 , -0.00029121, -0.00014826]) res_1 . fun . shape (10000,) res_1 . jac <10000x10000 sparse matrix of type '<class 'numpy.float64'>' with 49600 stored elements in Compressed Sparse Row format>","title":"Returned quantities after solution"},{"location":"intro/Numerical-Methods/#plot-the-solutions","text":"plt . figure(figsize = ( 16 , 5 )) plt . subplot( 131 ) plt . plot(res_1 . x) plt . subplot( 132 ) plt . imshow(res_1 . x . reshape((n, n)),\\ cmap = 'coolwarm' ,\\ vmin =- max ( abs (res_1 . x)),\\ vmax = max ( abs (res_1 . x))) plt . colorbar(use_gridspec = True ,\\ fraction = 0.046 ,\\ pad = 0.04 ) plt . subplot( 133 ) plt . plot(res_1 . fun) plt . tight_layout()","title":"Plot the solutions"},{"location":"intro/Numerical-Methods/#references","text":"http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main055.html https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares","title":"References:"}]}